/**
 * MindBase MCP Server - Conversation Tools
 *
 * Tool implementations for conversation management
 */

import type { StorageBackend, ConversationItem, QueryFilters } from '../storage/interface.js';

export class ConversationTools {
  private currentSessionId?: string;

  constructor(private storage: StorageBackend) {}

  /**
   * Set current session ID for context
   */
  setCurrentSession(sessionId: string | undefined) {
    this.currentSessionId = sessionId;
  }

  /**
   * conversation_save - Save conversation with automatic embedding
   */
  async conversationSave(args: {
    source: string;
    title: string;
    content: any;
    metadata?: Record<string, any>;
    category?: string;
    priority?: string;
    channel?: string;
    sessionId?: string;
  }): Promise<{ id: string; createdAt: string }> {
    const item: ConversationItem = {
      id: '', // Will be generated by storage
      sessionId: args.sessionId || this.currentSessionId,
      source: args.source as any,
      title: args.title,
      content: args.content,
      metadata: args.metadata || {},
      category: args.category as any,
      priority: args.priority as any,
      channel: args.channel,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const id = await this.storage.save(item);
    return {
      id,
      createdAt: item.createdAt.toISOString(),
    };
  }

  /**
   * conversation_get - Retrieve conversations with filtering
   */
  async conversationGet(args: {
    id?: string;
    source?: string;
    category?: string;
    priority?: string;
    channel?: string;
    sessionId?: string;
    limit?: number;
    offset?: number;
    createdAfter?: string;
    createdBefore?: string;
  }): Promise<{
    items: any[];
    total: number;
    hasMore: boolean;
  }> {
    // If ID is provided, get single item
    if (args.id) {
      const item = await this.storage.getById(args.id);
      if (!item) {
        return { items: [], total: 0, hasMore: false };
      }
      return {
        items: [this.formatItem(item)],
        total: 1,
        hasMore: false,
      };
    }

    // Otherwise, get with filters
    const filters: QueryFilters = {
      source: args.source,
      category: args.category,
      priority: args.priority,
      channel: args.channel,
      sessionId: args.sessionId || this.currentSessionId,
      limit: args.limit || 100,
      offset: args.offset || 0,
      createdAfter: args.createdAfter ? new Date(args.createdAfter) : undefined,
      createdBefore: args.createdBefore ? new Date(args.createdBefore) : undefined,
    };

    const items = await this.storage.get(filters);
    const total = items.length; // TODO: Get actual count from storage
    const hasMore = items.length === (args.limit || 100);

    return {
      items: items.map(this.formatItem),
      total,
      hasMore,
    };
  }

  /**
   * conversation_search - Semantic search across conversations
   */
  async conversationSearch(args: {
    query: string;
    threshold?: number;
    limit?: number;
    source?: string;
  }): Promise<{
    items: any[];
    query: string;
  }> {
    const threshold = args.threshold ?? 0.7;
    const limit = args.limit ?? 10;

    const results = await this.storage.semanticSearch(args.query, limit, threshold);

    // Filter by source if specified
    let filteredResults = results;
    if (args.source) {
      filteredResults = results.filter((r) => r.item.source === args.source);
    }

    return {
      items: filteredResults.map((result) => ({
        ...this.formatItem(result.item),
        similarity: result.similarity,
        semanticScore: result.semanticScore,
      })),
      query: args.query,
    };
  }

  /**
   * conversation_delete - Delete conversation by ID
   */
  async conversationDelete(args: { id: string }): Promise<{ success: boolean; deletedId?: string }> {
    const success = await this.storage.delete(args.id);
    return {
      success,
      deletedId: success ? args.id : undefined,
    };
  }

  /**
   * session_create - Create new session
   */
  async sessionCreate(args: {
    name: string;
    description?: string;
    parentId?: string;
  }): Promise<{ id: string; name: string; createdAt: string }> {
    const id = await this.storage.createSession(args.name, args.description, args.parentId);
    const session = await this.storage.getSession(id);

    if (!session) {
      throw new Error('Failed to retrieve created session');
    }

    return {
      id: session.id,
      name: session.name,
      createdAt: session.createdAt.toISOString(),
    };
  }

  /**
   * session_start - Start or resume a session
   */
  async sessionStart(args: {
    sessionId?: string;
    name?: string;
    description?: string;
  }): Promise<{
    id: string;
    name: string;
    description?: string;
    itemCount: number;
    createdAt: string;
  }> {
    let sessionId = args.sessionId;

    // If no sessionId provided, create new session
    if (!sessionId && args.name) {
      sessionId = await this.storage.createSession(args.name, args.description);
    }

    if (!sessionId) {
      throw new Error('Either sessionId or name must be provided');
    }

    const session = await this.storage.getSession(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }

    // Set as current session
    this.currentSessionId = session.id;

    return {
      id: session.id,
      name: session.name,
      description: session.description,
      itemCount: session.itemCount || 0,
      createdAt: session.createdAt.toISOString(),
    };
  }

  /**
   * session_list - List recent sessions
   */
  async sessionList(args?: { limit?: number }): Promise<{
    sessions: any[];
    total: number;
  }> {
    const limit = args?.limit || 10;
    const sessions = await this.storage.listSessions(limit);

    return {
      sessions: sessions.map((s) => ({
        id: s.id,
        name: s.name,
        description: s.description,
        parentId: s.parentId,
        itemCount: s.itemCount || 0,
        createdAt: s.createdAt.toISOString(),
        updatedAt: s.updatedAt.toISOString(),
      })),
      total: sessions.length,
    };
  }

  /**
   * session_delete - Delete a session
   */
  async sessionDelete(args: { id: string }): Promise<{ success: boolean; deletedId?: string }> {
    const success = await this.storage.deleteSession(args.id);

    // If deleted session was current, clear it
    if (success && this.currentSessionId === args.id) {
      this.currentSessionId = undefined;
    }

    return {
      success,
      deletedId: success ? args.id : undefined,
    };
  }

  /**
   * Format conversation item for output
   */
  private formatItem(item: ConversationItem): any {
    return {
      id: item.id,
      sessionId: item.sessionId,
      source: item.source,
      title: item.title,
      content: item.content,
      metadata: item.metadata,
      category: item.category,
      priority: item.priority,
      channel: item.channel,
      createdAt: item.createdAt.toISOString(),
      updatedAt: item.updatedAt.toISOString(),
    };
  }
}
